<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Datagrabber</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 24px;
        }

        .tabs {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }

        .tab-link {
            position: relative; /* Needed to position the pseudo-element */
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 20px;
            font-size: 14px;
            background-color: #e9ecef;
            color: #495057;
            transition: background-color 0.2s, color 0.2s;
        }

        /* Add space for the triangle after each tab except the last one */
        .tab-link:not(:last-child) {
            margin-right: 24px;
        }

        /* The triangle separator */
        .tab-link:not(:last-child)::after {
            content: '';
            position: absolute;
            top: 50%;
            right: -17px; /* Position it in the margin space */
            transform: translateY(-50%);
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 8px solid #b0b0b0; /* A neutral grey for the triangle */
        }

        .tab-link.active {
            background-color: #6c757d;
            color: #fff;
            font-weight: 600;
        }

        h1 {
            margin-bottom: 20px;
            color: #333;
            font-size: 24px;
        }

        .controls {
            display: flex;
            gap: 16px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        button.secondary {
            background: #28a745;
        }

        button.secondary:hover {
            background: #218838;
        }

        .series-control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f8f9fa;
        }

        .series-control-group label {
            font-size: 14px;
            color: #333;
        }

        #seriesSelect {
            padding: 6px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }

        .format-controls {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .format-control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .format-control-group label {
            font-size: 13px;
            color: #666;
            white-space: nowrap;
        }

        .format-control-group input[type="number"] {
            width: 60px;
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 13px;
        }

        .format-control-group select {
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 13px;
        }

        .toggle-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .toggle-group label {
            font-size: 14px;
            color: #666;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        input[type="radio"] {
            cursor: pointer;
        }

        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            background: #fafafa;
            margin-bottom: 20px;
            /* Flex properties to center content vertically */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 300px; /* Taller by default */
        }

        .upload-area.active {
            border-color: #007bff;
            background: #f0f8ff;
        }

        .canvas-container {
            position: relative;
            /* display: inline-block; */ /* Let the child canvas dictate the block layout */
            margin-bottom: 20px;
            border: 1px solid #ddd;
            background: #fff;
            max-width: 100%; /* Ensure container can shrink */
        }

        #canvasArea {
            text-align: center; /* Center the canvas container */
        }

        canvas {
            display: block;
            cursor: crosshair;
            height: auto; /* Let width and aspect ratio determine height */
            image-rendering: optimizeQuality; /* Optional: improve scaled image quality */
        }

        .instructions {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #856404;
        }

        .scale-inputs {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin-bottom: 20px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-group label {
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        .input-group input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .output-area {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 16px;
            margin-top: 20px;
        }

        .output-area h3 {
            margin-bottom: 12px;
            font-size: 16px;
            color: #333;
        }

        .output-area .output-table-container {
            background: white;
            padding: 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow-x: auto;
            display: flex;
            justify-content: flex-start;
        }

        .output-table {
            width: auto;
            min-width: 300px;
            border-collapse: collapse;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            font-size: 14px;
        }

        .output-table thead th {
            font-weight: 600;
            text-align: left;
            padding: 8px 16px;
            color: #333;
        }

        .output-table thead th.series-header {
            padding: 8px 16px;
        }

        .output-table thead th.series-header .series-pill {
            display: inline-block;
            border-radius: 20px;
            padding: 4px 12px;
            font-weight: 600;
            color: #333;
        }

        .output-table tbody td {
            font-weight: 400;
            text-align: left;
            padding: 6px 16px;
            color: #495057;
        }

        .output-table-container .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #999;
            font-style: italic;
            width: 100%;
        }

        .line-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            pointer-events: none;
        }

        .status {
            font-size: 14px;
            color: #666;
            margin-bottom: 12px;
        }

        .hidden {
            display: none;
        }

        /* Draggable Modal for Scale Input */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.1);
            z-index: 999;
        }

        .modal-content {
            position: absolute;
            background: white;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            border: 1px solid #ccc;
            padding: 16px;
            width: 280px;
            z-index: 1000;
        }

        .modal-header {
            padding-bottom: 12px;
            margin-bottom: 12px;
            border-bottom: 1px solid #eee;
            cursor: move;
            user-select: none;
        }

        .modal-header h4 {
            font-size: 16px;
            color: #333;
            margin: 0;
        }

        .modal-close-btn {
            position: absolute;
            top: 8px;
            right: 12px;
            background: none;
            border: none;
            font-size: 24px;
            line-height: 1;
            color: #888;
            cursor: pointer;
            padding: 0;
        }

        .modal-body .input-group {
            margin-bottom: 12px;
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>Datagrabber</h1>

        <div class="tabs">
            <div class="tab-link active" id="tab1">1. Upload Image</div>
            <div class="tab-link" id="tab2">Set Scale</div>
            <div class="tab-link" id="tab3">Grab Data</div>
        </div>

        <div id="step1Content">
            <div id="uploadContainer" style="display: flex; gap: 20px; margin-bottom: 20px;">
                <!-- Image preview appears here when an image is loaded -->
                <div id="imagePreviewWrapper" class="hidden" style="flex: 1;">
                    <h3 style="margin-bottom: 10px; color: #333;">Current Image</h3>
                    <div style="border: 1px solid #ddd; border-radius: 4px; padding: 10px; background: #f9f9f9; display: flex; flex-direction: column; align-items: center;">
                        <img id="imagePreview" src="" alt="Current chart image" style="max-width: 100%; height: auto; display: block; margin-bottom: 10px; border-radius: 4px;">
                        <p id="imageInfo" style="font-size: 13px; color: #555; text-align: center;"></p>
                    </div>
                </div>
                <!-- Upload area is always here, but its container changes width -->
                <div id="uploadAreaWrapper" style="flex: 1; display: flex; flex-direction: column;"> 
                    <h3 style="margin-bottom: 10px; visibility: hidden;">&nbsp;</h3>
                    <div class="upload-area">
                        <p id="uploadAreaMainText" style="font-size: 16px; color: #666;"><strong>Paste an image from clipboard (Ctrl/Cmd + V)</strong></p>
                        <p style="font-size: 14px; color: #999;">Or drag and drop a PNG/JPEG file here</p>
                        <input type="file" id="fileInput" accept="image/png,image/jpeg" style="display: none;"><button onclick="document.getElementById('fileInput').click()" style="margin-top: 12px;">Browse Files</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="step2Content" class="hidden">
             <div class="controls">
                 <div class="toggle-group">
                     <span style="font-weight: 600; color: #333;">Orientation:</span>
                     <input type="radio" id="orientationHorizontal" name="orientation" value="horizontal" checked>
                     <label for="orientationHorizontal">Horizontal</label>
                     <div style="width: 10px;"></div>
                     <input type="radio" id="orientationVertical" name="orientation" value="vertical">
                     <label for="orientationVertical">Vertical</label>
                 </div>
                 <button id="resetBtn">Reset All</button>
             </div>
             <div class="instructions">
                 <strong>Instructions:</strong> Click on the image to place 2 reference lines, then enter their values below.
                 <br><strong>Tip:</strong> Drag lines from their crosshair handles to adjust. Press Ctrl+Z to undo.
             </div>
             <div class="status" id="status"></div>
        </div>

        <div id="step3Content" class="hidden">
             <div class="controls">
                 <div class="series-control-group">
                    <label for="seriesSelect">Current Series:</label>
                    <select id="seriesSelect"></select>
                 </div>
                 <button id="newSeriesBtn" class="secondary">New Series</button>
                 <button id="clearLinesBtn">Clear Data Points</button>
             </div>
             <div class="instructions">
                 <strong>Instructions:</strong> Click on the image to place data points. Values will be calculated automatically.
                 <br><strong>Tip:</strong> Drag lines from their crosshair handles to adjust. Press Ctrl+Z to undo.
             </div>
        </div>

        <!-- Shared elements for steps 2 and 3 -->
        <div id="canvasArea" class="hidden">
             <div class="canvas-container" id="canvasContainer">
                 <canvas id="canvas"></canvas>
             </div>
 
            <div class="output-area">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; flex-wrap: wrap; gap: 12px;">
                    <h3 style="margin: 0;">Collected Data</h3>
                    <div style="display: flex; align-items: center; gap: 16px; flex-wrap: wrap;">
                        <div class="format-controls">
                            <div class="format-control-group">
                                <label for="precisionInput">Decimals:</label>
                                <input type="number" id="precisionInput" min="0" max="10" value="2">
                            </div>
                            <div class="format-control-group">
                                <label for="separatorSelect">Separator:</label>
                                <select id="separatorSelect">
                                    <option value="." selected>Period (.)</option>
                                    <option value=",">Comma (,)</option>
                                </select>
                            </div>
                        </div>
                        <button id="copyBtn" class="secondary">Copy to Clipboard</button>
                    </div>
                </div>
                <div class="output-table-container">
                    <div id="output"></div>
                </div>
            </div>
        </div>

        <!-- Draggable Modal for Scale Input -->
        <div id="scaleModal" class="modal-overlay hidden">
            <div class="modal-content" id="scaleModalContent">
                <div class="modal-header" id="scaleModalHeader">
                    <button id="modalCloseBtn" class="modal-close-btn">&times;</button>
                    <h4 id="modalTitle">Set Reference Value</h4>
                </div>
                <div class="modal-body">
                    <div class="input-group">
                        <label for="scaleValueInput" id="modalLabel">Value:</label>
                        <input type="text" id="scaleValueInput" placeholder="Enter numeric value">
                    </div>
                    <button id="modalSubmitBtn">Set Value</button>
                </div>
            </div>
        </div>


    </div>

    <script>
        // Tab and Step Content elements
        const tab1 = document.getElementById('tab1');
        const tab2 = document.getElementById('tab2');
        const tab3 = document.getElementById('tab3');
        const step1Content = document.getElementById('step1Content');
        const step2Content = document.getElementById('step2Content');
        const step3Content = document.getElementById('step3Content');
        const canvasArea = document.getElementById('canvasArea');
        const uploadContainer = document.getElementById('uploadContainer');
        const imagePreviewWrapper = document.getElementById('imagePreviewWrapper');
        const uploadAreaWrapper = document.getElementById('uploadAreaWrapper');
        const imagePreview = document.getElementById('imagePreview');
        const imageInfo = document.getElementById('imageInfo');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const orientationHorizontal = document.getElementById('orientationHorizontal');
        const orientationVertical = document.getElementById('orientationVertical');
        const resetBtn = document.getElementById('resetBtn');
        const clearLinesBtn = document.getElementById('clearLinesBtn');
        const newSeriesBtn = document.getElementById('newSeriesBtn');
        const copyBtn = document.getElementById('copyBtn');
        const seriesSelect = document.getElementById('seriesSelect');
        const precisionInput = document.getElementById('precisionInput');
        const separatorSelect = document.getElementById('separatorSelect');
        const status = document.getElementById('status');
        const output = document.getElementById('output');
        // Hidden inputs to store scale values
        const scale1Input = document.createElement('input');
        scale1Input.type = 'hidden';
        const scale2Input = document.createElement('input');
        scale2Input.type = 'hidden';

        const scaleModal = document.getElementById('scaleModal');

        let currentStep = 1;
        let currentImageFile = null; // To store the File/Blob object for size/type info
        let image = null;
        let series = [[]]; // Array of series, each series contains lines
        let currentSeriesIndex = 0;
        let scaleLines = [];
        let isVertical = false;
        let draggingLine = null;
        let dragOffset = 0;
        let history = []; // For undo functionality
        const DRAG_THRESHOLD = 10; // pixels - distance to detect if hovering over a handle
        const DRAG_SENSITIVITY = 0.3; // lower = less sensitive (slower drag)
        const INACTIVE_LINE_LENGTH = 30; // pixels - length of inactive lines on each side of crosshair
        const SERIES_COLORS = [
            { active: '#0066ff', inactive: '#0066ff66' },
            { active: '#ff6600', inactive: '#ff660066' },
            { active: '#00cc66', inactive: '#00cc6666' },
            { active: '#cc00cc', inactive: '#cc00cc66' },
            { active: '#ffcc00', inactive: '#ffcc0066' },
            { active: '#00cccc', inactive: '#00cccc66' }
        ];

        // --- Tab Navigation ---
        function goToStep(step, { force = false } = {}) {
            if (step === currentStep && !force) return;
            if (step > 1 && !image) return;
            if (step > 2 && (scaleLines.length < 2 || !scale1Input.value || !scale2Input.value)) return;

            currentStep = step;

            // Update tab active states
            [tab1, tab2, tab3].forEach(t => t.classList.remove('active'));
            document.getElementById(`tab${step}`).classList.add('active');

            // Show/hide content
            [step1Content, step2Content, step3Content, canvasArea].forEach(el => el.classList.add('hidden'));

            if (step === 1) {
                step1Content.classList.remove('hidden');
                if (image) {
                    document.querySelector('.upload-area').style.flexGrow = '1'; // Allow upload area to grow
                    imagePreviewWrapper.classList.remove('hidden');
                    uploadContainer.style.justifyContent = ''; // Reset justification
                    uploadAreaWrapper.style.maxWidth = ''; // Allow it to take full flex width
                    uploadAreaMainText.innerHTML = '<strong>Paste a new image from clipboard (Ctrl/Cmd + V)</strong>';
                    // updateImagePreview() is now called directly after image.onload
                } else {
                    document.querySelector('.upload-area').style.flexGrow = '0'; // Don't grow when centered
                    imagePreviewWrapper.classList.add('hidden');
                    uploadContainer.style.justifyContent = 'center'; // Center the flex item
                    uploadAreaWrapper.style.maxWidth = '600px'; // Constrain width
                }
            } else if (step === 2) {
                step2Content.classList.remove('hidden');
                canvasArea.classList.remove('hidden');
                output.parentElement.classList.add('hidden'); // Hide output in step 2
            } else if (step === 3) {
                step3Content.classList.remove('hidden');
                canvasArea.classList.remove('hidden');
                output.parentElement.classList.remove('hidden'); // Show output in step 3
                updateSeriesControls(); // Ensure series picker is initialized
            }
            updateStatus();
            draw();
        }

        tab1.addEventListener('click', () => goToStep(1));
        tab2.addEventListener('click', () => goToStep(2));
        tab3.addEventListener('click', () => goToStep(3));

        function updateTabAccessibility() {
            tab2.style.cursor = image ? 'pointer' : 'not-allowed';
            tab2.style.color = image ? '' : '#ccc';
            const scaleSet = scaleLines.length === 2 && scale1Input.value && scale2Input.value;
            tab3.style.cursor = scaleSet ? 'pointer' : 'not-allowed';
            tab3.style.color = scaleSet ? '' : '#ccc';
        }

        // Undo functionality (Ctrl+Z)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                undo();
            }
        });

        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.querySelector('.upload-area');
        const uploadAreaMainText = document.getElementById('uploadAreaMainText');

        // Paste from clipboard
        document.addEventListener('paste', (e) => {
            const items = e.clipboardData.items;
            for (let item of items) {
                if (item.type.indexOf('image') !== -1) {
                    const blob = item.getAsFile();
                    loadImage(blob);
                    e.preventDefault();
                    break;
                }
            }
        });

        // File input
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                loadImage(e.target.files[0]);
            }
        });

        // Drag and drop
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('active');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('active');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('active');
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type.match(/image\/(png|jpeg)/)) {
                loadImage(files[0]);
            }
        });

        function loadImage(file) {
            currentImageFile = file; // Store the file for info
            const reader = new FileReader();
            reader.onload = (e) => {
                image = new Image();
                image.onload = () => {
                    canvas.width = image.width;
                    canvas.height = image.height;

                    // --- New, more robust flow ---
                    // 1. Reset all data model state
                    series = [[]];
                    currentSeriesIndex = 0;
                    scaleLines = [];
                    draggingLine = null;
                    history = [];
                    scale1Input.value = '';
                    scale2Input.value = '';

                    // 2. Update the UI now that the image is fully loaded and state is reset
                    updateImagePreview();
                    goToStep(1, { force: true }); // This will now correctly show the preview
                    updateTabAccessibility();
                };
                image.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function resizeCanvasToFit() {
            if (!image) return;

            // Available space: container width and a portion of viewport height
            const container = document.getElementById('canvasContainer');
            const availW = container.clientWidth || container.offsetWidth;
            // Leave room for UI elements above and below the canvas
            const availH = Math.max(300, window.innerHeight - 350); 

            // Scale factor to "contain" the image in both dimensions, without upscaling
            const scale = Math.min(availW / image.width, availH / image.height, 1);

            // Set CSS size (visual size). Keep bitmap (canvas.width/height) = image dims
            // so drawing math stays simple & precise.
            canvas.style.width  = `${Math.round(image.width * scale)}px`;
            canvas.style.height = `${Math.round(image.height * scale)}px`;

            // Redraw to keep overlays crisp at current zoom
            draw();
        }

        function saveState() {
            history.push({
                series: JSON.parse(JSON.stringify(series)),
                currentSeriesIndex: currentSeriesIndex,
                scaleLines: JSON.parse(JSON.stringify(scaleLines)),
                scale1Value: scale1Input.value,
                scale2Value: scale2Input.value
            });
        }

        function updateImagePreview() {
            if (image && currentImageFile) {
                imagePreview.src = image.src;
                imagePreview.style.display = 'block'; // Ensure image is visible

                const fileSizeKB = (currentImageFile.size / 1024).toFixed(2);
                const fileType = (currentImageFile.type || 'unknown').replace('image/', '');
                const dimensions = `${image.width}px x ${image.height}px`;

                imageInfo.innerHTML = `
                    <strong>File Type:</strong> ${fileType}<br>
                    <strong>Dimensions:</strong> ${dimensions}<br>
                    <strong>Size:</strong> ${fileSizeKB} KB
                `;
                imageInfo.style.display = 'block';
            } else {
                imagePreview.src = '';
                imagePreview.style.display = 'none';
                imageInfo.innerHTML = '';
                imageInfo.style.display = 'none';
            }
        }


        function undo() {
            if (history.length === 0) return;

            const state = history.pop();
            series = state.series;
            currentSeriesIndex = state.currentSeriesIndex;
            scaleLines = state.scaleLines;
            scale1Input.value = state.scale1Value;
            scale2Input.value = state.scale2Value;

            // Restore state might change step validity, so update tabs and status
            updateTabAccessibility();
            updateSeriesControls();
            updateStatus();
            updateOutput();
            draw();
        }

        // --- Wrap goToStep to ensure canvas is resized on layout changes ---
        const originalGoToStep = goToStep;
        goToStep = function(step, opts) {
            originalGoToStep(step, opts);
            // Ensure canvas fits after UI changes (e.g., output area appearing)
            resizeCanvasToFit();
        };
        window.addEventListener('resize', resizeCanvasToFit);

        function updateSeriesControls() {
            // Clear existing options
            seriesSelect.innerHTML = '';

            // Populate dropdown with series
            series.forEach((s, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `Series ${index + 1}`;
                seriesSelect.appendChild(option);
            });

            // Set the selected option
            seriesSelect.value = currentSeriesIndex;

            // Update status and redraw
            updateStatus();
            draw();
        }


        function reset() {
            saveState(); // Allow undoing the reset

            if (currentStep === 2) {
                // Reset only scale lines and their values
                scaleLines = [];
                scale1Input.value = '';
                scale2Input.value = '';
                // Also clear all data points, as they depend on the scale
                series = [[]];
                currentSeriesIndex = 0;
                updateSeriesControls();
            } else if (currentStep === 3) {
                // In step 3, "Reset All" should probably clear all series data
                series = [[]];
                currentSeriesIndex = 0;
                updateSeriesControls();
            }
            updateStatus();
            updateOutput(); // This also calls updateTabAccessibility
            draw();
        }
        goToStep(1); // Initialize the view on page load

        function handleOrientationChange() {
            isVertical = orientationVertical.checked;
            reset(); // Reset lines on orientation change as positions are relative
        }

        orientationHorizontal.addEventListener('change', () => {
            if (orientationHorizontal.checked) handleOrientationChange();
        });
        orientationVertical.addEventListener('change', () => {
            if (orientationVertical.checked) handleOrientationChange();
        });

        resetBtn.addEventListener('click', () => {
            // The reset button should only reset the current step's data,
            // not the entire application state.
            // We can call reset() which is now context-aware.
            reset();
        });

        clearLinesBtn.addEventListener('click', () => {
            saveState();
            if (currentSeriesIndex > 0) {
                // If it's not the first series, remove it entirely
                series.splice(currentSeriesIndex, 1);
                // Adjust the current index to a valid one (the previous one)
                currentSeriesIndex = Math.max(0, currentSeriesIndex - 1);
                updateSeriesControls(); // Rebuilds dropdown, updates status, and redraws
            } else {
                // If it's the first series, just clear its data points
                series[currentSeriesIndex] = [];
                // We need to manually update status and redraw since updateSeriesControls isn't called
                updateStatus();
                draw();
            }
            updateOutput(); // Update the text output area
        });

        newSeriesBtn.addEventListener('click', () => {
            saveState();
            currentSeriesIndex = series.length;
            series.push([]);
            updateSeriesControls();
        });

        seriesSelect.addEventListener('change', (e) => {
            saveState();
            currentSeriesIndex = parseInt(e.target.value, 10);
            // No need to call updateSeriesControls, just update status and redraw
            updateStatus();
            draw();
        });

        precisionInput.addEventListener('input', updateOutput);
        separatorSelect.addEventListener('change', updateOutput);

        copyBtn.addEventListener('click', () => {
            const text = generateOutputText();
            navigator.clipboard.writeText(text).then(() => {
                const originalText = copyBtn.textContent;
                copyBtn.textContent = 'Copied!';
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                }, 2000);
            }).catch(err => {
                alert('Failed to copy to clipboard. Please select and copy manually.');
            });
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const { scaleX, scaleY } = getCanvasScale();
            const originalX = x / scaleX;
            const originalY = y / scaleY;

            // Check if clicking on an existing line handle
            const clickedLine = findLineAtPoint(originalX, originalY);

            if (clickedLine) {
                draggingLine = clickedLine;
                const currentPos = isVertical ? clickedLine.pos : clickedLine.pos; // This is in original coords
                e.preventDefault();
                return;
            }

            // If not dragging, place a new line (save state first)
            saveState();
            if (currentStep === 2 && scaleLines.length < 2) { // Place in original coords
                scaleLines.push({ pos: isVertical ? originalX : originalY, fixedCoord: isVertical ? originalY : originalX });
                if (scaleLines.length === 2) {
                    showScaleModal(2, e.clientX, e.clientY);
                    updateTabAccessibility();
                }
            } else if (currentStep === 3 && scale1Input.value && scale2Input.value) {
                series[currentSeriesIndex].push({ pos: isVertical ? originalX : originalY, fixedCoord: isVertical ? originalY : originalX });
                updateOutput();
            } else {
                history.pop(); // Don't save state if no action was taken
            }
            updateStatus();
            if (currentStep === 2 && scaleLines.length === 1) {
                showScaleModal(1, e.clientX, e.clientY);
            }
            draw();
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const { scaleX, scaleY } = getCanvasScale();
            const originalX = x / scaleX;
            const originalY = y / scaleY;

            if (draggingLine) {
                // Apply drag sensitivity
                const rawPos = (isVertical ? originalX : originalY) - dragOffset; // Convert mouse pos to original coords
                const currentPos = draggingLine.pos;
                const delta = (rawPos - currentPos) * DRAG_SENSITIVITY;
                draggingLine.pos = currentPos + delta;

                updateOutput();
                draw();
                e.preventDefault();
            } else {
                // Update cursor if hovering over a handle (use original coords)
                const hoveredLine = findLineAtPoint(originalX, originalY);
                // Update cursor if hovering over a handle (use original coords)
                canvas.style.cursor = hoveredLine ? 'grab' : 'crosshair';
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (draggingLine) {
                saveState(); // Save state after dragging completes
                canvas.style.cursor = 'crosshair';
            }
            draggingLine = null;
        });

        canvas.addEventListener('mouseleave', () => {
            draggingLine = null;
            canvas.style.cursor = 'crosshair';
        });

        function findLineAtPoint(x, y) {
            // Check scale lines first
            for (let line of scaleLines) {
                if (isNearHandle(x, y, line)) {
                    return line;
                }
            }
            // Then check data lines from all series
            for (let seriesLines of series) {
                for (let line of seriesLines) {
                    if (isNearHandle(x, y, line)) {
                        return line;
                    }
                }
            }
            return null;
        }

        function getCanvasScale() {
            if (!image) return { scaleX: 1, scaleY: 1 };
            const rect = canvas.getBoundingClientRect(); // actual on-screen size
            return {
                scaleX: rect.width  / image.width,
                scaleY: rect.height / image.height
            };
        }

        function isNearHandle(x, y, line) {
            if (isVertical) {
                return Math.abs(x - line.pos) < DRAG_THRESHOLD &&
                       Math.abs(y - line.fixedCoord) < DRAG_THRESHOLD;
            } else {
                return Math.abs(y - line.pos) < DRAG_THRESHOLD &&
                       Math.abs(x - line.fixedCoord) < DRAG_THRESHOLD;
            }
        }

        scale1Input.addEventListener('input', updateOutput);
        scale2Input.addEventListener('input', updateOutput);

        function updateStatus() {
            let statusText = '';
            if (currentStep === 2) {
                if (scaleLines.length === 0) {
                    statusText = 'Click on the image to set the first scale reference line.';
                } else if (scaleLines.length === 1) {
                    statusText = 'Click to set the second scale reference line.';
                } else if (!scale1Input.value || !scale2Input.value) {
                    statusText = 'Enter the values for both reference lines above.';
                } else {
                    statusText = 'Scale set! You can now proceed to Step 3 to grab data points.';
                }
            } else if (currentStep === 3) {
                 const currentSeriesLines = series[currentSeriesIndex] || [];
                 statusText = `Click to add data points to Series ${currentSeriesIndex + 1}. (${currentSeriesLines.length} data point${currentSeriesLines.length !== 1 ? 's' : ''} in current series)`;
            }
            status.textContent = statusText;
            updateTabAccessibility();
        }

        // --- Scale Input Modal Logic ---
        const scaleModalContent = document.getElementById('scaleModalContent');
        const scaleModalHeader = document.getElementById('scaleModalHeader');
        const modalTitle = document.getElementById('modalTitle');
        const modalLabel = document.getElementById('modalLabel');
        const scaleValueInput = document.getElementById('scaleValueInput');
        const modalSubmitBtn = document.getElementById('modalSubmitBtn');
        const modalCloseBtn = document.getElementById('modalCloseBtn');
        let currentModalRef = 0;

        function showScaleModal(refNumber, x, y) {
            currentModalRef = refNumber;
            modalTitle.textContent = `Set Reference ${refNumber} Value`;
            modalLabel.htmlFor = `scaleValueInput`;
            modalLabel.textContent = `Reference Line ${refNumber} Value:`;
            scaleValueInput.value = refNumber === 1 ? scale1Input.value : scale2Input.value;
            scaleValueInput.style.borderColor = ''; // Reset border color

            // Position modal near the click event
            scaleModalContent.style.left = `${x + 20}px`;
            scaleModalContent.style.top = `${y - 40}px`;

            scaleModal.classList.remove('hidden');
            scaleValueInput.focus();
            handleModalInputChange(); // Check initial state for button
            scaleValueInput.select();
        }

        function hideScaleModal() {
            scaleModal.classList.add('hidden');
            updateOutput();
            updateTabAccessibility();
            draw();
        }

        modalSubmitBtn.addEventListener('click', () => {
            // Normalize the input value (handles both commas and periods)
            const normalized = normalizeNumericInput(scaleValueInput.value);
            if (normalized === null) return;

            if (currentModalRef === 1) {
                scale1Input.value = normalized;
            } else {
                scale2Input.value = normalized;
            }
            // Clear the input for the next time the modal is opened
            scaleValueInput.value = '';
            scaleValueInput.style.borderColor = ''; // Reset border color
            hideScaleModal();
        });

        scaleValueInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                modalSubmitBtn.click();
            }
        });

        modalCloseBtn.addEventListener('click', () => {
            // Closing the modal should undo the point placement that triggered it.
            // The state was saved right before the point was added.
            undo();
            hideScaleModal();
        });

        // Normalize user input to handle both commas and periods as decimal separators
        function normalizeNumericInput(input) {
            const trimmed = input.trim();
            if (trimmed === '') return null;

            // Replace comma with period for consistent decimal handling
            const normalized = trimmed.replace(',', '.');

            // Check if it's a valid number
            const num = parseFloat(normalized);
            if (isNaN(num)) return null;

            return normalized;
        }

        // Disable/enable submit button based on input
        function handleModalInputChange() {
            const normalized = normalizeNumericInput(scaleValueInput.value);
            const isValid = normalized !== null;
            modalSubmitBtn.disabled = !isValid;

            // Visual feedback for invalid input
            if (scaleValueInput.value.trim() !== '' && !isValid) {
                scaleValueInput.style.borderColor = '#dc3545';
            } else {
                scaleValueInput.style.borderColor = '';
            }
        }

        scaleValueInput.addEventListener('input', handleModalInputChange);

        // Drag logic for the modal
        let isDraggingModal = false;
        let modalOffsetX, modalOffsetY;
        scaleModalHeader.addEventListener('mousedown', (e) => {
            isDraggingModal = true;
            modalOffsetX = e.clientX - scaleModalContent.offsetLeft;
            modalOffsetY = e.clientY - scaleModalContent.offsetTop;
        });
        document.addEventListener('mousemove', (e) => {
            if (!isDraggingModal) return;
            scaleModalContent.style.left = `${e.clientX - modalOffsetX}px`;
            scaleModalContent.style.top = `${e.clientY - modalOffsetY}px`;
        });
        document.addEventListener('mouseup', () => isDraggingModal = false);

        function draw() {
            if (!image) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(image, 0, 0);

            // Draw scale lines (red)
            if (currentStep >= 2) { scaleLines.forEach((line, index) => {
                // line.pos and line.fixedCoord are already in canvas (original image) coordinates
                const linePos = line.pos;
                const fixedCoord = line.fixedCoord;
                const isScaleStep = currentStep === 2;
                const isActive = draggingLine === line;

                let color = '#ff0000'; // Red for scale step
                if (!isScaleStep) color = '#888888'; // Grey for data step

                ctx.strokeStyle = isActive ? color : `${color}99`;
                ctx.lineWidth = 2;

                if (!isScaleStep) ctx.setLineDash([5, 5]); // Dashed in data step
                ctx.beginPath();
                if (isActive) {
                    // Draw full line when active
                    if (isVertical) {
                        ctx.moveTo(linePos, 0);
                        ctx.lineTo(linePos, canvas.height);
                    } else {
                        ctx.moveTo(0, linePos);
                        ctx.lineTo(canvas.width, linePos);
                    }
                } else {
                    // Draw short line around crosshair when inactive
                    if (isVertical) {
                        ctx.moveTo(linePos, Math.max(0, fixedCoord - INACTIVE_LINE_LENGTH));
                        ctx.lineTo(linePos, Math.min(canvas.height, fixedCoord + INACTIVE_LINE_LENGTH));
                    } else {
                        ctx.moveTo(Math.max(0, fixedCoord - INACTIVE_LINE_LENGTH), linePos);
                        ctx.lineTo(Math.min(canvas.width, fixedCoord + INACTIVE_LINE_LENGTH), linePos);
                    }
                }
                ctx.stroke();
                ctx.setLineDash([]); // Reset dash for other lines

                // Draw crosshair handle at the fixed coordinate
                drawHandle(linePos, fixedCoord, isActive ? color : `${color}99`);

                // Label
                ctx.fillStyle = isActive ? color : `${color}99`;
                ctx.font = '12px Arial';
                const label = `Ref ${index + 1}`;
                if (isVertical) {
                    ctx.fillText(label, linePos + 5, 15);
                } else {
                    ctx.fillText(label, 5, linePos - 5);
                }
            });}

            // Draw data lines from all series
            if (currentStep === 3) {
                series.forEach((seriesLines, seriesIndex) => {
                const color = SERIES_COLORS[seriesIndex % SERIES_COLORS.length];
                const isCurrentSeries = seriesIndex === currentSeriesIndex;

                seriesLines.forEach((line, lineIndex) => {
                    // line.pos and line.fixedCoord are already in canvas (original image) coordinates
                    const linePos = line.pos;
                    const fixedCoord = line.fixedCoord;
                    const isActive = draggingLine === line;
                    ctx.strokeStyle = isActive ? color.active : color.inactive;
                    ctx.lineWidth = 1.5;

                    ctx.beginPath();
                    if (isActive) {
                        // Draw full line when active
                        if (isVertical) {
                            ctx.moveTo(linePos, 0);
                            ctx.lineTo(linePos, canvas.height);
                        } else {
                            ctx.moveTo(0, linePos);
                            ctx.lineTo(canvas.width, linePos);
                        }
                    } else {
                        // Draw short line around crosshair when inactive
                        if (isVertical) {
                            ctx.moveTo(linePos, Math.max(0, fixedCoord - INACTIVE_LINE_LENGTH));
                            ctx.lineTo(linePos, Math.min(canvas.height, fixedCoord + INACTIVE_LINE_LENGTH));
                        } else {
                            ctx.moveTo(Math.max(0, fixedCoord - INACTIVE_LINE_LENGTH), linePos);
                            ctx.lineTo(Math.min(canvas.width, fixedCoord + INACTIVE_LINE_LENGTH), linePos);
                        }
                    }
                    ctx.stroke();

                    // Draw crosshair handle at the fixed coordinate
                    drawHandle(linePos, fixedCoord, isActive ? color.active : color.inactive);

                    // Label with series indicator
                    ctx.fillStyle = isActive ? color.active : color.inactive;
                    ctx.font = '11px Arial';
                    const label = `S${seriesIndex + 1}:${lineIndex + 1}`;
                    if (isVertical) {
                        ctx.fillText(label, linePos + 3, 30 + (seriesIndex * 15));
                    } else {
                        ctx.fillText(label, 5 + (seriesIndex * 35), linePos - 5);
                    }
                });
            });}
        }

        function drawHandle(linePos, fixedCoord, color) {
            const handleSize = 8;
            ctx.strokeStyle = color;
            ctx.lineWidth = 1; // Handle line width can remain constant or scale

            if (isVertical) {
                // Draw small crosshair at (linePos, fixedCoord)
                ctx.beginPath();
                ctx.moveTo(linePos - handleSize, fixedCoord);
                ctx.lineTo(linePos + handleSize, fixedCoord);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(linePos, fixedCoord - handleSize);
                ctx.lineTo(linePos, fixedCoord + handleSize);
                ctx.stroke();
            } else {
                // Draw small crosshair at (fixedCoord, linePos)
                ctx.beginPath();
                ctx.moveTo(fixedCoord - handleSize, linePos);
                ctx.lineTo(fixedCoord + handleSize, linePos);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(fixedCoord, linePos - handleSize);
                ctx.lineTo(fixedCoord, linePos + handleSize);
                ctx.stroke();
            }
        }

        function calculateValue(position) {
            if (scaleLines.length < 2 || !scale1Input.value || !scale2Input.value) {
                return null;
            }

            const pos1 = scaleLines[0].pos;
            const pos2 = scaleLines[1].pos;
            const val1 = parseFloat(scale1Input.value);
            const val2 = parseFloat(scale2Input.value);

            // Linear interpolation
            const ratio = (position - pos1) / (pos2 - pos1);
            const value = val1 + ratio * (val2 - val1);

            return value;
        }

        function formatValue(value) {
            if (value === null || value === undefined || value === '') return '';

            const precision = parseInt(precisionInput.value);
            const separator = separatorSelect.value;

            // Format with specified precision
            let formatted = typeof value === 'number' ? value.toFixed(precision) : parseFloat(value).toFixed(precision);

            // Replace decimal separator if comma is selected
            if (separator === ',') {
                formatted = formatted.replace('.', ',');
            }

            return formatted;
        }

        function generateOutputData() {
            if (!scale1Input.value || !scale2Input.value) {
                return null;
            }

            // Check if any series has data
            const hasData = series.some(s => s.length > 0);
            if (!hasData) {
                return null;
            }

            // Sort each series by position coordinate (left-to-right for horizontal, top-to-bottom for vertical)
            const sortedSeries = series.map(seriesData => {
                if (seriesData.length === 0) return seriesData;

                // Sort by the coordinate perpendicular to the measurement axis
                // For horizontal charts: sort by fixedCoord (X position, left to right)
                // For vertical charts: sort by fixedCoord (Y position, top to bottom)
                return [...seriesData].sort((a, b) => a.fixedCoord - b.fixedCoord);
            });

            // Find max number of rows needed
            const maxRows = Math.max(...sortedSeries.map(s => s.length));

            // Build header
            const headers = ['Index'];
            for (let i = 0; i < sortedSeries.length; i++) {
                if (sortedSeries[i].length > 0) {
                    headers.push(`Series ${i + 1}`);
                }
            }

            // Build data rows
            const rows = [];
            for (let row = 0; row < maxRows; row++) {
                const rowData = [row + 1];
                for (let seriesIndex = 0; seriesIndex < sortedSeries.length; seriesIndex++) {
                    if (sortedSeries[seriesIndex].length > 0) {
                        const line = sortedSeries[seriesIndex][row];
                        if (line) {
                            const value = calculateValue(line.pos);
                            const formatted = formatValue(value);
                            rowData.push(formatted);
                        } else {
                            rowData.push('');
                        }
                    }
                }
                rows.push(rowData);
            }

            return { headers, rows };
        }

        function generateOutputText() {
            const data = generateOutputData();
            if (!data) {
                return 'No data points yet. Click on the chart to add data points.';
            }

            // Generate tab-delimited text
            let result = data.headers.join('\t') + '\n';
            for (const row of data.rows) {
                result += row.join('\t') + '\n';
            }
            return result;
        }

        function generateOutputHTML() {
            const data = generateOutputData();
            if (!data) {
                return '<div class="empty-state">No data points yet. Click on the chart to add data points.</div>';
            }

            // Generate HTML table
            let html = '<table class="output-table"><thead><tr>';
            for (let i = 0; i < data.headers.length; i++) {
                const header = data.headers[i];

                // Check if this is a Series header (not "Index")
                if (header.startsWith('Series ')) {
                    // Extract series number (e.g., "Series 1" -> index 0)
                    const seriesNum = parseInt(header.split(' ')[1]) - 1;
                    const color = SERIES_COLORS[seriesNum % SERIES_COLORS.length];
                    // Use a faint background (0.2 opacity) with the active color
                    const bgColor = color.active + '33'; // Add 33 for ~20% opacity
                    html += `<th class="series-header"><span class="series-pill" style="background-color: ${bgColor};">${header}</span></th>`;
                } else {
                    html += `<th>${header}</th>`;
                }
            }
            html += '</tr></thead><tbody>';
            for (const row of data.rows) {
                html += '<tr>';
                for (const cell of row) {
                    html += `<td>${cell}</td>`;
                }
                html += '</tr>';
            }
            html += '</tbody></table>';
            return html;
        }

        function updateOutput() {
            output.innerHTML = generateOutputHTML();
            updateTabAccessibility();
        }

        // updateTabAccessibility(); // Initial call is now handled by goToStep(1)
    </script>
</body>



</html>