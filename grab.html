<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chart Data Grabber</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 24px;
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }

        .tab-link {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            margin-bottom: -1px;
            font-size: 16px;
            color: #666;
        }

        .tab-link.active {
            border-color: #ddd;
            border-bottom: 1px solid white;
            border-radius: 4px 4px 0 0;
            background: white;
            color: #007bff;
            font-weight: 600;
        }

        h1 {
            margin-bottom: 20px;
            color: #333;
            font-size: 24px;
        }

        .controls {
            display: flex;
            gap: 16px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        button.secondary {
            background: #28a745;
        }

        button.secondary:hover {
            background: #218838;
        }

        .series-control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f8f9fa;
        }

        .series-control-group label {
            font-size: 14px;
            color: #333;
        }

        #seriesSelect {
            padding: 6px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }

        .toggle-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .toggle-group label {
            font-size: 14px;
            color: #666;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            background: #fafafa;
            margin-bottom: 20px;
        }

        .upload-area.active {
            border-color: #007bff;
            background: #f0f8ff;
        }

        .canvas-container {
            position: relative;
            display: inline-block;
            margin-bottom: 20px;
            border: 1px solid #ddd;
            background: #fff;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        .instructions {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #856404;
        }

        .scale-inputs {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin-bottom: 20px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-group label {
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        .input-group input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .output-area {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 16px;
            margin-top: 20px;
        }

        .output-area h3 {
            margin-bottom: 12px;
            font-size: 16px;
            color: #333;
        }

        .output-area pre {
            background: white;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            white-space: pre;
        }

        .line-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            pointer-events: none;
        }

        .status {
            font-size: 14px;
            color: #666;
            margin-bottom: 12px;
        }

        .hidden {
            display: none;
        }

        /* Draggable Modal for Scale Input */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.1);
            z-index: 999;
        }

        .modal-content {
            position: absolute;
            background: white;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            border: 1px solid #ccc;
            padding: 16px;
            width: 280px;
            z-index: 1000;
        }

        .modal-header {
            padding-bottom: 12px;
            margin-bottom: 12px;
            border-bottom: 1px solid #eee;
            cursor: move;
            user-select: none;
        }

        .modal-header h4 {
            font-size: 16px;
            color: #333;
            margin: 0;
        }

        .modal-body .input-group {
            margin-bottom: 12px;
        }


    </style>
</head>
<body>
    <div class="container">
        <h1>Chart Data Grabber</h1>

        <div class="tabs">
            <div class="tab-link active" id="tab1">Step 1: Upload Image</div>
            <div class="tab-link" id="tab2">Step 2: Set Scale</div>
            <div class="tab-link" id="tab3">Step 3: Grab Data</div>
        </div>

        <div id="step1Content">
        <div id="uploadArea" class="upload-area">
            <p style="font-size: 16px; color: #666; margin-bottom: 12px;">
                <strong>Paste an image from clipboard (Ctrl/Cmd + V)</strong>
            </p>
            <p style="font-size: 14px; color: #999;">
                Or drag and drop a PNG/JPEG file here
            </p>
            <input type="file" id="fileInput" accept="image/png,image/jpeg" style="display: none;">
            <button onclick="document.getElementById('fileInput').click()" style="margin-top: 12px;">
                Browse Files
            </button>
        </div>
        </div>

        <div id="step2Content" class="hidden">
             <div class="controls">
                 <div class="toggle-group">
                     <input type="checkbox" id="orientationToggle">
                     <label for="orientationToggle">Vertical Orientation</label>
                 </div>
                 <button id="resetBtn">Reset All</button>
             </div>
             <div class="instructions">
                 <strong>Instructions:</strong> Click on the image to place 2 reference lines, then enter their values below.
                 <br><strong>Tip:</strong> Drag lines from their crosshair handles to adjust. Press Ctrl+Z to undo.
             </div>
             <div class="status" id="status"></div>
        </div>

        <div id="step3Content" class="hidden">
             <div class="controls">
                 <div class="series-control-group">
                    <label for="seriesSelect">Current Series:</label>
                    <select id="seriesSelect"></select>
                 </div>
                 <button id="newSeriesBtn" class="secondary">New Series</button>
                 <button id="clearLinesBtn">Clear Data Points</button>
             </div>
             <div class="instructions">
                 <strong>Instructions:</strong> Click on the image to place data points. Values will be calculated automatically.
                 <br><strong>Tip:</strong> Drag lines from their crosshair handles to adjust. Press Ctrl+Z to undo.
             </div>
        </div>

        <!-- Shared elements for steps 2 and 3 -->
        <div id="canvasArea" class="hidden">
             <div class="canvas-container" id="canvasContainer">
                 <canvas id="canvas"></canvas>
             </div>
 
            <div class="output-area">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <h3 style="margin: 0;">Data Output (Tab-delimited for Excel)</h3>
                    <button id="copyBtn" class="secondary">Copy to Clipboard</button>
                </div>
                <pre id="output">No data points yet. Click on the chart to add data points.</pre>
            </div>
        </div>

        <!-- Draggable Modal for Scale Input -->
        <div id="scaleModal" class="modal-overlay hidden">
            <div class="modal-content" id="scaleModalContent">
                <div class="modal-header" id="scaleModalHeader">
                    <h4 id="modalTitle">Set Reference Value</h4>
                </div>
                <div class="modal-body">
                    <div class="input-group">
                        <label for="scaleValueInput" id="modalLabel">Value:</label>
                        <input type="number" id="scaleValueInput" step="any" placeholder="e.g., 0">
                    </div>
                    <button id="modalSubmitBtn">Set Value</button>
                </div>
            </div>
        </div>


    </div>

    <script>
        // Tab and Step Content elements
        const tab1 = document.getElementById('tab1');
        const tab2 = document.getElementById('tab2');
        const tab3 = document.getElementById('tab3');
        const step1Content = document.getElementById('step1Content');
        const step2Content = document.getElementById('step2Content');
        const step3Content = document.getElementById('step3Content');
        const canvasArea = document.getElementById('canvasArea');
        const uploadArea = document.getElementById('uploadArea');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const fileInput = document.getElementById('fileInput');
        const orientationToggle = document.getElementById('orientationToggle');
        const resetBtn = document.getElementById('resetBtn');
        const clearLinesBtn = document.getElementById('clearLinesBtn');
        const newSeriesBtn = document.getElementById('newSeriesBtn');
        const copyBtn = document.getElementById('copyBtn');
        const seriesSelect = document.getElementById('seriesSelect');
        const status = document.getElementById('status');
        const output = document.getElementById('output');
        // Hidden inputs to store scale values
        const scale1Input = document.createElement('input');
        scale1Input.type = 'hidden';
        const scale2Input = document.createElement('input');
        scale2Input.type = 'hidden';

        const scaleModal = document.getElementById('scaleModal');

        let currentStep = 1;
        let image = null;
        let series = [[]]; // Array of series, each series contains lines
        let currentSeriesIndex = 0;
        let scaleLines = [];
        let isVertical = false;
        let draggingLine = null;
        let dragOffset = 0;
        let history = []; // For undo functionality
        const DRAG_THRESHOLD = 10; // pixels - distance to detect if hovering over a handle
        const DRAG_SENSITIVITY = 0.3; // lower = less sensitive (slower drag)
        const INACTIVE_LINE_LENGTH = 30; // pixels - length of inactive lines on each side of crosshair
        const SERIES_COLORS = [
            { active: '#0066ff', inactive: '#0066ff66' },
            { active: '#ff6600', inactive: '#ff660066' },
            { active: '#00cc66', inactive: '#00cc6666' },
            { active: '#cc00cc', inactive: '#cc00cc66' },
            { active: '#ffcc00', inactive: '#ffcc0066' },
            { active: '#00cccc', inactive: '#00cccc66' }
        ];

        // --- Tab Navigation ---
        function goToStep(step) {
            if (step === currentStep) return;

            // Disable clicking future steps
            if (step > 1 && !image) return;
            if (step > 2 && (scaleLines.length < 2 || !scale1Input.value || !scale2Input.value)) return;

            currentStep = step;

            // Update tab active states
            [tab1, tab2, tab3].forEach(t => t.classList.remove('active'));
            document.getElementById(`tab${step}`).classList.add('active');

            // Show/hide content
            [step1Content, step2Content, step3Content, canvasArea].forEach(el => el.classList.add('hidden'));

            if (step === 1) {
                step1Content.classList.remove('hidden');
                uploadArea.classList.remove('hidden');
            } else if (step === 2) {
                step2Content.classList.remove('hidden');
                canvasArea.classList.remove('hidden');
                output.parentElement.classList.add('hidden'); // Hide output in step 2
            } else if (step === 3) {
                step3Content.classList.remove('hidden');
                canvasArea.classList.remove('hidden');
                output.parentElement.classList.remove('hidden'); // Show output in step 3
                updateSeriesControls(); // Ensure series picker is initialized
            }
            updateStatus();
            draw();
        }

        tab1.addEventListener('click', () => goToStep(1));
        tab2.addEventListener('click', () => goToStep(2));
        tab3.addEventListener('click', () => goToStep(3));

        function updateTabAccessibility() {
            tab2.style.cursor = image ? 'pointer' : 'not-allowed';
            tab2.style.color = image ? '' : '#ccc';
            const scaleSet = scaleLines.length === 2 && scale1Input.value && scale2Input.value;
            tab3.style.cursor = scaleSet ? 'pointer' : 'not-allowed';
            tab3.style.color = scaleSet ? '' : '#ccc';
        }

        // Undo functionality (Ctrl+Z)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                undo();
            }
        });

        // Paste from clipboard
        document.addEventListener('paste', (e) => {
            const items = e.clipboardData.items;
            for (let item of items) {
                if (item.type.indexOf('image') !== -1) {
                    const blob = item.getAsFile();
                    loadImage(blob);
                    e.preventDefault();
                    break;
                }
            }
        });

        // File input
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                loadImage(e.target.files[0]);
            }
        });

        // Drag and drop
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('active');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('active');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('active');
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type.match(/image\/(png|jpeg)/)) {
                loadImage(files[0]);
            }
        });

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                image = new Image();
                image.onload = () => {
                    canvas.width = image.width;
                    canvas.height = image.height;
                    reset();
                    goToStep(2);
                    updateTabAccessibility();
                };
                image.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function saveState() {
            history.push({
                series: JSON.parse(JSON.stringify(series)),
                currentSeriesIndex: currentSeriesIndex,
                scaleLines: JSON.parse(JSON.stringify(scaleLines)),
                scale1Value: scale1Input.value,
                scale2Value: scale2Input.value
            });
        }

        function undo() {
            if (history.length === 0) return;

            const state = history.pop();
            series = state.series;
            currentSeriesIndex = state.currentSeriesIndex;
            scaleLines = state.scaleLines;
            scale1Input.value = state.scale1Value;
            scale2Input.value = state.scale2Value;

            // Restore state might change step validity, so update tabs and status
            updateTabAccessibility();
            updateSeriesControls();
            updateStatus();
            updateOutput();
            draw();
        }

        function updateSeriesControls() {
            // Clear existing options
            seriesSelect.innerHTML = '';

            // Populate dropdown with series
            series.forEach((s, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `Series ${index + 1}`;
                seriesSelect.appendChild(option);
            });

            // Set the selected option
            seriesSelect.value = currentSeriesIndex;

            // Update status and redraw
            updateStatus();
            draw();
        }

        function reset() {
            saveState(); // Allow undoing the reset

            if (currentStep === 2) {
                // Reset only scale lines and their values
                scaleLines = [];
                scale1Input.value = '';
                scale2Input.value = '';
                // Also clear all data points, as they depend on the scale
                series = [[]];
                currentSeriesIndex = 0;
                updateSeriesControls();
            } else if (currentStep === 3) {
                // In step 3, "Reset All" should probably clear all series data
                series = [[]];
                currentSeriesIndex = 0;
                updateSeriesControls();
            } else {
                // Full reset (e.g., from orientation change or new image)
                series = [[]];
                currentSeriesIndex = 0;
                scaleLines = [];
                draggingLine = null;
                history = []; // Clear history on full reset
                scale1Input.value = '';
                scale2Input.value = '';
                if (!image) goToStep(1); // If no image, go back to step 1
            }
            updateStatus();
            updateOutput(); // This also calls updateTabAccessibility
            draw();
        }

        orientationToggle.addEventListener('change', (e) => {
            isVertical = e.target.checked;
            reset(); // Reset lines on orientation change as positions are relative
        });

        resetBtn.addEventListener('click', () => {
            // The reset button should only reset the current step's data,
            // not the entire application state.
            // We can call reset() which is now context-aware.
            reset();
        });

        clearLinesBtn.addEventListener('click', () => {
            saveState();
            if (currentSeriesIndex > 0) {
                // If it's not the first series, remove it entirely
                series.splice(currentSeriesIndex, 1);
                // Adjust the current index to a valid one (the previous one)
                currentSeriesIndex = Math.max(0, currentSeriesIndex - 1);
                updateSeriesControls(); // Rebuilds dropdown, updates status, and redraws
            } else {
                // If it's the first series, just clear its data points
                series[currentSeriesIndex] = [];
                // We need to manually update status and redraw since updateSeriesControls isn't called
                updateStatus();
                draw();
            }
            updateOutput(); // Update the text output area
        });

        newSeriesBtn.addEventListener('click', () => {
            saveState();
            currentSeriesIndex = series.length;
            series.push([]);
            updateSeriesControls();
        });

        seriesSelect.addEventListener('change', (e) => {
            saveState();
            currentSeriesIndex = parseInt(e.target.value, 10);
            // No need to call updateSeriesControls, just update status and redraw
            updateStatus();
            draw();
        });

        copyBtn.addEventListener('click', () => {
            const text = generateOutputText();
            navigator.clipboard.writeText(text).then(() => {
                const originalText = copyBtn.textContent;
                copyBtn.textContent = 'Copied!';
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                }, 2000);
            }).catch(err => {
                alert('Failed to copy to clipboard. Please select and copy manually.');
            });
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check if clicking on an existing line handle
            const clickedLine = findLineAtPoint(x, y);

            if (clickedLine) {
                draggingLine = clickedLine;
                const currentPos = isVertical ? clickedLine.pos : clickedLine.pos;
                dragOffset = (isVertical ? x : y) - currentPos;
                e.preventDefault();
                return;
            }

            // If not dragging, place a new line (save state first)
            saveState();
            if (currentStep === 2 && scaleLines.length < 2) {
                scaleLines.push({ pos: isVertical ? x : y, fixedCoord: isVertical ? y : x });
                if (scaleLines.length === 2) {
                    showScaleModal(2, e.clientX, e.clientY);
                    updateTabAccessibility();
                }
            } else if (currentStep === 3 && scale1Input.value && scale2Input.value) {
                series[currentSeriesIndex].push({ pos: isVertical ? x : y, fixedCoord: isVertical ? y : x });
                updateOutput();
            } else {
                history.pop(); // Don't save state if no action was taken
            }
            updateStatus();
            if (currentStep === 2 && scaleLines.length === 1) {
                showScaleModal(1, e.clientX, e.clientY);
            }
            draw();
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (draggingLine) {
                // Apply drag sensitivity
                const rawPos = (isVertical ? x : y) - dragOffset;
                const currentPos = draggingLine.pos;
                const delta = (rawPos - currentPos) * DRAG_SENSITIVITY;
                draggingLine.pos = currentPos + delta;

                updateOutput();
                draw();
                e.preventDefault();
            } else {
                // Update cursor if hovering over a handle
                const hoveredLine = findLineAtPoint(x, y);
                canvas.style.cursor = hoveredLine ? 'grab' : 'crosshair';
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (draggingLine) {
                saveState(); // Save state after dragging completes
                canvas.style.cursor = 'crosshair';
            }
            draggingLine = null;
        });

        canvas.addEventListener('mouseleave', () => {
            draggingLine = null;
            canvas.style.cursor = 'crosshair';
        });

        function findLineAtPoint(x, y) {
            // Check scale lines first
            for (let line of scaleLines) {
                if (isNearHandle(x, y, line)) {
                    return line;
                }
            }
            // Then check data lines from all series
            for (let seriesLines of series) {
                for (let line of seriesLines) {
                    if (isNearHandle(x, y, line)) {
                        return line;
                    }
                }
            }
            return null;
        }

        function isNearHandle(x, y, line) {
            if (isVertical) {
                return Math.abs(x - line.pos) < DRAG_THRESHOLD &&
                       Math.abs(y - line.fixedCoord) < DRAG_THRESHOLD;
            } else {
                return Math.abs(y - line.pos) < DRAG_THRESHOLD &&
                       Math.abs(x - line.fixedCoord) < DRAG_THRESHOLD;
            }
        }

        scale1Input.addEventListener('input', updateOutput);
        scale2Input.addEventListener('input', updateOutput);

        function updateStatus() {
            let statusText = '';
            if (currentStep === 2) {
                if (scaleLines.length === 0) {
                    statusText = 'Click on the image to set the first scale reference line.';
                } else if (scaleLines.length === 1) {
                    statusText = 'Click to set the second scale reference line.';
                } else if (!scale1Input.value || !scale2Input.value) {
                    statusText = 'Enter the values for both reference lines above.';
                } else {
                    statusText = 'Scale set! You can now proceed to Step 3 to grab data points.';
                }
            } else if (currentStep === 3) {
                 const currentSeriesLines = series[currentSeriesIndex] || [];
                 statusText = `Click to add data points to Series ${currentSeriesIndex + 1}. (${currentSeriesLines.length} data point${currentSeriesLines.length !== 1 ? 's' : ''} in current series)`;
            }
            status.textContent = statusText;
            updateTabAccessibility();
        }

        // --- Scale Input Modal Logic ---
        const scaleModalContent = document.getElementById('scaleModalContent');
        const scaleModalHeader = document.getElementById('scaleModalHeader');
        const modalTitle = document.getElementById('modalTitle');
        const modalLabel = document.getElementById('modalLabel');
        const scaleValueInput = document.getElementById('scaleValueInput');
        const modalSubmitBtn = document.getElementById('modalSubmitBtn');
        let currentModalRef = 0;

        function showScaleModal(refNumber, x, y) {
            currentModalRef = refNumber;
            modalTitle.textContent = `Set Reference ${refNumber} Value`;
            modalLabel.htmlFor = `scaleValueInput`;
            modalLabel.textContent = `Reference Line ${refNumber} Value:`;
            scaleValueInput.value = refNumber === 1 ? scale1Input.value : scale2Input.value;
            
            // Position modal near the click event
            scaleModalContent.style.left = `${x + 20}px`;
            scaleModalContent.style.top = `${y - 40}px`;

            scaleModal.classList.remove('hidden');
            scaleValueInput.focus();
            scaleValueInput.select();
        }

        function hideScaleModal() {
            scaleModal.classList.add('hidden');
            updateOutput();
            updateTabAccessibility();
            draw();
        }

        modalSubmitBtn.addEventListener('click', () => {
            if (currentModalRef === 1) {
                scale1Input.value = scaleValueInput.value;
            } else {
                scale2Input.value = scaleValueInput.value;
            }
            hideScaleModal();
        });

        scaleValueInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                modalSubmitBtn.click();
            }
        });

        // Drag logic for the modal
        let isDraggingModal = false;
        let modalOffsetX, modalOffsetY;
        scaleModalHeader.addEventListener('mousedown', (e) => {
            isDraggingModal = true;
            modalOffsetX = e.clientX - scaleModalContent.offsetLeft;
            modalOffsetY = e.clientY - scaleModalContent.offsetTop;
        });
        document.addEventListener('mousemove', (e) => {
            if (!isDraggingModal) return;
            scaleModalContent.style.left = `${e.clientX - modalOffsetX}px`;
            scaleModalContent.style.top = `${e.clientY - modalOffsetY}px`;
        });
        document.addEventListener('mouseup', () => isDraggingModal = false);

        function draw() {
            if (!image) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(image, 0, 0);

            // Draw scale lines (red)
            if (currentStep >= 2) { scaleLines.forEach((line, index) => {
                const isScaleStep = currentStep === 2;
                const isActive = draggingLine === line;
                
                let color = '#ff0000'; // Red for scale step
                if (!isScaleStep) color = '#888888'; // Grey for data step

                ctx.strokeStyle = isActive ? color : `${color}99`;
                ctx.lineWidth = 2;

                if (!isScaleStep) ctx.setLineDash([5, 5]); // Dashed in data step
                ctx.beginPath();
                if (isActive) {
                    // Draw full line when active
                    if (isVertical) {
                        ctx.moveTo(line.pos, 0);
                        ctx.lineTo(line.pos, canvas.height);
                    } else {
                        ctx.moveTo(0, line.pos);
                        ctx.lineTo(canvas.width, line.pos);
                    }
                } else {
                    // Draw short line around crosshair when inactive
                    if (isVertical) {
                        ctx.moveTo(line.pos, Math.max(0, line.fixedCoord - INACTIVE_LINE_LENGTH));
                        ctx.lineTo(line.pos, Math.min(canvas.height, line.fixedCoord + INACTIVE_LINE_LENGTH));
                    } else {
                        ctx.moveTo(Math.max(0, line.fixedCoord - INACTIVE_LINE_LENGTH), line.pos);
                        ctx.lineTo(Math.min(canvas.width, line.fixedCoord + INACTIVE_LINE_LENGTH), line.pos);
                    }
                }
                ctx.stroke();
                ctx.setLineDash([]); // Reset dash for other lines

                // Draw crosshair handle at the fixed coordinate
                drawHandle(line.pos, line.fixedCoord, isActive ? color : `${color}99`);

                // Label
                ctx.fillStyle = isActive ? color : `${color}99`;
                ctx.font = '12px Arial';
                const label = `Ref ${index + 1}`;
                if (isVertical) {
                    ctx.fillText(label, line.pos + 5, 15);
                } else {
                    ctx.fillText(label, 5, line.pos - 5);
                }
            });}

            // Draw data lines from all series
            if (currentStep === 3) {
                series.forEach((seriesLines, seriesIndex) => {
                const color = SERIES_COLORS[seriesIndex % SERIES_COLORS.length];
                const isCurrentSeries = seriesIndex === currentSeriesIndex;

                seriesLines.forEach((line, lineIndex) => {
                    const isActive = draggingLine === line;
                    ctx.strokeStyle = isActive ? color.active : color.inactive;
                    ctx.lineWidth = 1.5;

                    ctx.beginPath();
                    if (isActive) {
                        // Draw full line when active
                        if (isVertical) {
                            ctx.moveTo(line.pos, 0);
                            ctx.lineTo(line.pos, canvas.height);
                        } else {
                            ctx.moveTo(0, line.pos);
                            ctx.lineTo(canvas.width, line.pos);
                        }
                    } else {
                        // Draw short line around crosshair when inactive
                        if (isVertical) {
                            ctx.moveTo(line.pos, Math.max(0, line.fixedCoord - INACTIVE_LINE_LENGTH));
                            ctx.lineTo(line.pos, Math.min(canvas.height, line.fixedCoord + INACTIVE_LINE_LENGTH));
                        } else {
                            ctx.moveTo(Math.max(0, line.fixedCoord - INACTIVE_LINE_LENGTH), line.pos);
                            ctx.lineTo(Math.min(canvas.width, line.fixedCoord + INACTIVE_LINE_LENGTH), line.pos);
                        }
                    }
                    ctx.stroke();

                    // Draw crosshair handle at the fixed coordinate
                    drawHandle(line.pos, line.fixedCoord, isActive ? color.active : color.inactive);

                    // Label with series indicator
                    ctx.fillStyle = isActive ? color.active : color.inactive;
                    ctx.font = '11px Arial';
                    const label = `S${seriesIndex + 1}:${lineIndex + 1}`;
                    if (isVertical) {
                        ctx.fillText(label, line.pos + 3, 30 + (seriesIndex * 15));
                    } else {
                        ctx.fillText(label, 5 + (seriesIndex * 35), line.pos - 5);
                    }
                });
            });}
        }

        function drawHandle(linePos, fixedCoord, color) {
            const handleSize = 8;
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;

            if (isVertical) {
                // Draw small crosshair at (linePos, fixedCoord)
                ctx.beginPath();
                ctx.moveTo(linePos - handleSize, fixedCoord);
                ctx.lineTo(linePos + handleSize, fixedCoord);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(linePos, fixedCoord - handleSize);
                ctx.lineTo(linePos, fixedCoord + handleSize);
                ctx.stroke();
            } else {
                // Draw small crosshair at (fixedCoord, linePos)
                ctx.beginPath();
                ctx.moveTo(fixedCoord - handleSize, linePos);
                ctx.lineTo(fixedCoord + handleSize, linePos);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(fixedCoord, linePos - handleSize);
                ctx.lineTo(fixedCoord, linePos + handleSize);
                ctx.stroke();
            }
        }

        function calculateValue(position) {
            if (scaleLines.length < 2 || !scale1Input.value || !scale2Input.value) {
                return null;
            }

            const pos1 = scaleLines[0].pos;
            const pos2 = scaleLines[1].pos;
            const val1 = parseFloat(scale1Input.value);
            const val2 = parseFloat(scale2Input.value);

            // Linear interpolation
            const ratio = (position - pos1) / (pos2 - pos1);
            const value = val1 + ratio * (val2 - val1);

            return value.toFixed(2);
        }

        function generateOutputText() {
            if (!scale1Input.value || !scale2Input.value) {
                return 'No data points yet. Click on the chart to add data points.';
            }

            // Check if any series has data
            const hasData = series.some(s => s.length > 0);
            if (!hasData) {
                return 'No data points yet. Click on the chart to add data points.';
            }

            // Find max number of rows needed
            const maxRows = Math.max(...series.map(s => s.length));

            // Build header
            let result = 'Index';
            for (let i = 0; i < series.length; i++) {
                if (series[i].length > 0) {
                    result += `\tSeries ${i + 1}`;
                }
            }
            result += '\n';

            // Build data rows
            for (let row = 0; row < maxRows; row++) {
                result += (row + 1);
                for (let seriesIndex = 0; seriesIndex < series.length; seriesIndex++) {
                    if (series[seriesIndex].length > 0) {
                        const line = series[seriesIndex][row];
                        if (line) {
                            const value = calculateValue(line.pos);
                            result += `\t${value}`;
                        } else {
                            result += '\t';
                        }
                    }
                }
                result += '\n';
            }

            return result;
        }

        function updateOutput() {
            output.textContent = generateOutputText();
            updateTabAccessibility();
        }

        updateTabAccessibility(); // Initial call
    </script>
</body>
</html>