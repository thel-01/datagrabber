<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Datagrabber</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 24px;
        }

        .tabs {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }

        .tab-link {
            position: relative; /* Needed to position the pseudo-element */
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 20px;
            font-size: 14px;
            background-color: #e9ecef;
            color: #495057;
            transition: background-color 0.2s, color 0.2s;
        }

        /* Add space for the triangle after each tab except the last one */
        .tab-link:not(:last-child) {
            margin-right: 24px;
        }

        /* The triangle separator */
        .tab-link:not(:last-child)::after {
            content: '';
            position: absolute;
            top: 50%;
            right: -17px; /* Position it in the margin space */
            transform: translateY(-50%);
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 8px solid #b0b0b0; /* A neutral grey for the triangle */
        }

        .tab-link.active {
            background-color: #6c757d;
            color: #fff;
            font-weight: 600;
        }

        h1 {
            margin-bottom: 20px;
            color: #333;
            font-size: 24px;
        }

        .controls {
            display: flex;
            gap: 16px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        button.secondary {
            background: #28a745;
        }

        button.secondary:hover {
            background: #218838;
        }

        .series-control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f8f9fa;
        }

        .series-control-group label {
            font-size: 14px;
            color: #333;
        }

        #seriesSelect {
            padding: 6px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }

        .toggle-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .toggle-group label {
            font-size: 14px;
            color: #666;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        input[type="radio"] {
            cursor: pointer;
        }

        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            background: #fafafa;
            margin-bottom: 20px;
        }

        .upload-area.active {
            border-color: #007bff;
            background: #f0f8ff;
        }

        .canvas-container {
            position: relative;
            display: inline-block;
            margin-bottom: 20px;
            border: 1px solid #ddd;
            background: #fff;
            text-align: center; /* Center the canvas */
        }

        #canvasArea {
            text-align: center; /* Center the canvas container */
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        .instructions {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #856404;
        }

        .scale-inputs {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin-bottom: 20px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-group label {
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        .input-group input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .output-area {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 16px;
            margin-top: 20px;
        }

        .output-area h3 {
            margin-bottom: 12px;
            font-size: 16px;
            color: #333;
        }

        .output-area pre {
            background: white;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            white-space: pre;
        }

        .line-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            pointer-events: none;
        }

        .status {
            font-size: 14px;
            color: #666;
            margin-bottom: 12px;
        }

        .hidden {
            display: none;
        }

        /* Draggable Modal for Scale Input */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.1);
            z-index: 999;
        }

        .modal-content {
            position: absolute;
            background: white;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            border: 1px solid #ccc;
            padding: 16px;
            width: 280px;
            z-index: 1000;
        }

        .modal-header {
            padding-bottom: 12px;
            margin-bottom: 12px;
            border-bottom: 1px solid #eee;
            cursor: move;
            user-select: none;
        }

        .modal-header h4 {
            font-size: 16px;
            color: #333;
            margin: 0;
        }

        .modal-body .input-group {
            margin-bottom: 12px;
        }


    </style>
</head>
<body>
    <div class="container">
        <h1>Datagrabber</h1>

        <div class="tabs">
            <div class="tab-link active" id="tab1">Upload Image</div>
            <div class="tab-link" id="tab2">Set Scale</div>
            <div class="tab-link" id="tab3">Grab Data</div>
        </div>

        <div id="step1Content">
            <div id="uploadContainer" style="display: flex; gap: 20px; margin-bottom: 20px;">
                <!-- Image preview appears here when an image is loaded -->
                <div id="imagePreviewWrapper" class="hidden" style="flex: 1;">
                    <h3 style="margin-bottom: 10px; color: #333;">Current Image</h3>
                    <div style="border: 1px solid #ddd; border-radius: 4px; padding: 10px; background: #f9f9f9; display: flex; flex-direction: column; align-items: center;">
                        <img id="imagePreview" src="" alt="Current chart image" style="max-width: 100%; height: auto; display: block; margin-bottom: 10px; border-radius: 4px;">
                        <p id="imageInfo" style="font-size: 13px; color: #555; text-align: center;"></p>
                    </div>
                </div>
                <!-- Upload area is always here, but its container changes width -->
                <div id="uploadAreaWrapper" style="flex: 1;"> 
                    <div id="uploadAreaSpacer" class="hidden" style="height: 29px;"></div>
                    <div class="upload-area">
                        <p id="uploadAreaMainText" style="font-size: 16px; color: #666; margin-bottom: 12px;"><strong>Paste an image from clipboard (Ctrl/Cmd + V)</strong></p>
                        <p style="font-size: 14px; color: #999;">Or drag and drop a PNG/JPEG file here</p>
                        <input type="file" id="fileInput" accept="image/png,image/jpeg" style="display: none;"><button onclick="document.getElementById('fileInput').click()" style="margin-top: 12px;">Browse Files</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="step2Content" class="hidden">
             <div class="controls">
                 <div class="toggle-group">
                     <span style="font-weight: 600; color: #333;">Orientation:</span>
                     <input type="radio" id="orientationHorizontal" name="orientation" value="horizontal" checked>
                     <label for="orientationHorizontal">Horizontal</label>
                     <div style="width: 10px;"></div>
                     <input type="radio" id="orientationVertical" name="orientation" value="vertical">
                     <label for="orientationVertical">Vertical</label>
                 </div>
                 <button id="resetBtn">Reset All</button>
             </div>
             <div class="instructions">
                 <strong>Instructions:</strong> Click on the image to place 2 reference lines, then enter their values below.
                 <br><strong>Tip:</strong> Drag lines from their crosshair handles to adjust. Press Ctrl+Z to undo.
             </div>
             <div class="status" id="status"></div>
        </div>

        <div id="step3Content" class="hidden">
             <div class="controls">
                 <div class="series-control-group">
                    <label for="seriesSelect">Current Series:</label>
                    <select id="seriesSelect"></select>
                 </div>
                 <button id="newSeriesBtn" class="secondary">New Series</button>
                 <button id="clearLinesBtn">Clear Data Points</button>
             </div>
             <div class="instructions">
                 <strong>Instructions:</strong> Click on the image to place data points. Values will be calculated automatically.
                 <br><strong>Tip:</strong> Drag lines from their crosshair handles to adjust. Press Ctrl+Z to undo.
             </div>
        </div>

        <!-- Shared elements for steps 2 and 3 -->
        <div id="canvasArea" class="hidden">
             <div class="canvas-container" id="canvasContainer">
                 <canvas id="canvas"></canvas>
             </div>
 
            <div class="output-area">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <h3 style="margin: 0;">Data Output (Tab-delimited for Excel)</h3>
                    <button id="copyBtn" class="secondary">Copy to Clipboard</button>
                </div>
                <pre id="output">No data points yet. Click on the chart to add data points.</pre>
            </div>
        </div>

        <!-- Draggable Modal for Scale Input -->
        <div id="scaleModal" class="modal-overlay hidden">
            <div class="modal-content" id="scaleModalContent">
                <div class="modal-header" id="scaleModalHeader">
                    <h4 id="modalTitle">Set Reference Value</h4>
                </div>
                <div class="modal-body">
                    <div class="input-group">
                        <label for="scaleValueInput" id="modalLabel">Value:</label>
                        <input type="number" id="scaleValueInput" step="any" placeholder="e.g., 0">
                    </div>
                    <button id="modalSubmitBtn">Set Value</button>
                </div>
            </div>
        </div>


    </div>

    <script>
        // Tab and Step Content elements
        const tab1 = document.getElementById('tab1');
        const tab2 = document.getElementById('tab2');
        const tab3 = document.getElementById('tab3');
        const step1Content = document.getElementById('step1Content');
        const step2Content = document.getElementById('step2Content');
        const step3Content = document.getElementById('step3Content');
        const canvasArea = document.getElementById('canvasArea');
        const uploadContainer = document.getElementById('uploadContainer');
        const imagePreviewWrapper = document.getElementById('imagePreviewWrapper');
        const uploadAreaWrapper = document.getElementById('uploadAreaWrapper');
        const uploadAreaSpacer = document.getElementById('uploadAreaSpacer');
        const imagePreview = document.getElementById('imagePreview');
        const imageInfo = document.getElementById('imageInfo');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const orientationHorizontal = document.getElementById('orientationHorizontal');
        const orientationVertical = document.getElementById('orientationVertical');
        const resetBtn = document.getElementById('resetBtn');
        const clearLinesBtn = document.getElementById('clearLinesBtn');
        const newSeriesBtn = document.getElementById('newSeriesBtn');
        const copyBtn = document.getElementById('copyBtn');
        const seriesSelect = document.getElementById('seriesSelect');
        const status = document.getElementById('status');
        const output = document.getElementById('output');
        // Hidden inputs to store scale values
        const scale1Input = document.createElement('input');
        scale1Input.type = 'hidden';
        const scale2Input = document.createElement('input');
        scale2Input.type = 'hidden';

        const scaleModal = document.getElementById('scaleModal');

        let currentStep = 1;
        let currentImageFile = null; // To store the File/Blob object for size/type info
        let image = null;
        let series = [[]]; // Array of series, each series contains lines
        let currentSeriesIndex = 0;
        let scaleLines = [];
        let isVertical = false;
        let draggingLine = null;
        let dragOffset = 0;
        let history = []; // For undo functionality
        const DRAG_THRESHOLD = 10; // pixels - distance to detect if hovering over a handle
        const DRAG_SENSITIVITY = 0.3; // lower = less sensitive (slower drag)
        const INACTIVE_LINE_LENGTH = 30; // pixels - length of inactive lines on each side of crosshair
        const SERIES_COLORS = [
            { active: '#0066ff', inactive: '#0066ff66' },
            { active: '#ff6600', inactive: '#ff660066' },
            { active: '#00cc66', inactive: '#00cc6666' },
            { active: '#cc00cc', inactive: '#cc00cc66' },
            { active: '#ffcc00', inactive: '#ffcc0066' },
            { active: '#00cccc', inactive: '#00cccc66' }
        ];

        // --- Tab Navigation ---
        function goToStep(step, { force = false } = {}) {
            if (step === currentStep && !force) return;
            if (step > 1 && !image) return;
            if (step > 2 && (scaleLines.length < 2 || !scale1Input.value || !scale2Input.value)) return;

            currentStep = step;

            // Update tab active states
            [tab1, tab2, tab3].forEach(t => t.classList.remove('active'));
            document.getElementById(`tab${step}`).classList.add('active');

            // Show/hide content
            [step1Content, step2Content, step3Content, canvasArea].forEach(el => el.classList.add('hidden'));

            if (step === 1) {
                step1Content.classList.remove('hidden');
                if (image) {
                    imagePreviewWrapper.classList.remove('hidden');
                    uploadContainer.style.justifyContent = ''; // Reset justification
                    uploadAreaWrapper.style.maxWidth = ''; // Allow it to take full flex width
                    uploadAreaSpacer.classList.remove('hidden'); // Show spacer
                    uploadAreaMainText.innerHTML = '<strong>Paste a new image from clipboard (Ctrl/Cmd + V)</strong>';
                    // updateImagePreview() is now called directly after image.onload
                } else {
                    imagePreviewWrapper.classList.add('hidden');
                    uploadContainer.style.justifyContent = 'center'; // Center the flex item
                    uploadAreaWrapper.style.maxWidth = '600px'; // Constrain width
                    uploadAreaSpacer.classList.add('hidden'); // Hide spacer
                }
            } else if (step === 2) {
                step2Content.classList.remove('hidden');
                canvasArea.classList.remove('hidden');
                output.parentElement.classList.add('hidden'); // Hide output in step 2
            } else if (step === 3) {
                step3Content.classList.remove('hidden');
                canvasArea.classList.remove('hidden');
                output.parentElement.classList.remove('hidden'); // Show output in step 3
                updateSeriesControls(); // Ensure series picker is initialized
            }
            updateStatus();
            draw();
        }

        tab1.addEventListener('click', () => goToStep(1));
        tab2.addEventListener('click', () => goToStep(2));
        tab3.addEventListener('click', () => goToStep(3));

        function updateTabAccessibility() {
            tab2.style.cursor = image ? 'pointer' : 'not-allowed';
            tab2.style.color = image ? '' : '#ccc';
            const scaleSet = scaleLines.length === 2 && scale1Input.value && scale2Input.value;
            tab3.style.cursor = scaleSet ? 'pointer' : 'not-allowed';
            tab3.style.color = scaleSet ? '' : '#ccc';
        }

        // Undo functionality (Ctrl+Z)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                undo();
            }
        });

        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.querySelector('.upload-area');
        const uploadAreaMainText = document.getElementById('uploadAreaMainText');

        // Paste from clipboard
        document.addEventListener('paste', (e) => {
            const items = e.clipboardData.items;
            for (let item of items) {
                if (item.type.indexOf('image') !== -1) {
                    const blob = item.getAsFile();
                    loadImage(blob);
                    e.preventDefault();
                    break;
                }
            }
        });

        // File input
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                loadImage(e.target.files[0]);
            }
        });

        // Drag and drop
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('active');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('active');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('active');
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type.match(/image\/(png|jpeg)/)) {
                loadImage(files[0]);
            }
        });

        function loadImage(file) {
            currentImageFile = file; // Store the file for info
            const reader = new FileReader();
            reader.onload = (e) => {
                image = new Image();
                image.onload = () => {
                    canvas.width = image.width;
                    canvas.height = image.height;

                    // --- New, more robust flow ---
                    // 1. Reset all data model state
                    series = [[]];
                    currentSeriesIndex = 0;
                    scaleLines = [];
                    draggingLine = null;
                    history = [];
                    scale1Input.value = '';
                    scale2Input.value = '';

                    // 2. Update the UI now that the image is fully loaded and state is reset
                    updateImagePreview();
                    goToStep(1, { force: true }); // This will now correctly show the preview
                    updateTabAccessibility();
                };
                image.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function saveState() {
            history.push({
                series: JSON.parse(JSON.stringify(series)),
                currentSeriesIndex: currentSeriesIndex,
                scaleLines: JSON.parse(JSON.stringify(scaleLines)),
                scale1Value: scale1Input.value,
                scale2Value: scale2Input.value
            });
        }

        function updateImagePreview() {
            if (image && currentImageFile) {
                imagePreview.src = image.src;
                imagePreview.style.display = 'block'; // Ensure image is visible

                const fileSizeKB = (currentImageFile.size / 1024).toFixed(2);
                const fileType = (currentImageFile.type || 'unknown').replace('image/', '');
                const dimensions = `${image.width}px x ${image.height}px`;

                imageInfo.innerHTML = `
                    <strong>File Type:</strong> ${fileType}<br>
                    <strong>Dimensions:</strong> ${dimensions}<br>
                    <strong>Size:</strong> ${fileSizeKB} KB
                `;
                imageInfo.style.display = 'block';
            } else {
                imagePreview.src = '';
                imagePreview.style.display = 'none';
                imageInfo.innerHTML = '';
                imageInfo.style.display = 'none';
            }
        }


        function undo() {
            if (history.length === 0) return;

            const state = history.pop();
            series = state.series;
            currentSeriesIndex = state.currentSeriesIndex;
            scaleLines = state.scaleLines;
            scale1Input.value = state.scale1Value;
            scale2Input.value = state.scale2Value;

            // Restore state might change step validity, so update tabs and status
            updateTabAccessibility();
            updateSeriesControls();
            updateStatus();
            updateOutput();
            draw();
        }

        function updateSeriesControls() {
            // Clear existing options
            seriesSelect.innerHTML = '';

            // Populate dropdown with series
            series.forEach((s, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `Series ${index + 1}`;
                seriesSelect.appendChild(option);
            });

            // Set the selected option
            seriesSelect.value = currentSeriesIndex;

            // Update status and redraw
            updateStatus();
            draw();
        }


        function reset() {
            saveState(); // Allow undoing the reset

            if (currentStep === 2) {
                // Reset only scale lines and their values
                scaleLines = [];
                scale1Input.value = '';
                scale2Input.value = '';
                // Also clear all data points, as they depend on the scale
                series = [[]];
                currentSeriesIndex = 0;
                updateSeriesControls();
            } else if (currentStep === 3) {
                // In step 3, "Reset All" should probably clear all series data
                series = [[]];
                currentSeriesIndex = 0;
                updateSeriesControls();
            }
            updateStatus();
            updateOutput(); // This also calls updateTabAccessibility
            draw();
        }
        goToStep(1); // Initialize the view on page load

        function handleOrientationChange() {
            isVertical = orientationVertical.checked;
            reset(); // Reset lines on orientation change as positions are relative
        }

        orientationHorizontal.addEventListener('change', () => {
            if (orientationHorizontal.checked) handleOrientationChange();
        });
        orientationVertical.addEventListener('change', () => {
            if (orientationVertical.checked) handleOrientationChange();
        });

        resetBtn.addEventListener('click', () => {
            // The reset button should only reset the current step's data,
            // not the entire application state.
            // We can call reset() which is now context-aware.
            reset();
        });

        clearLinesBtn.addEventListener('click', () => {
            saveState();
            if (currentSeriesIndex > 0) {
                // If it's not the first series, remove it entirely
                series.splice(currentSeriesIndex, 1);
                // Adjust the current index to a valid one (the previous one)
                currentSeriesIndex = Math.max(0, currentSeriesIndex - 1);
                updateSeriesControls(); // Rebuilds dropdown, updates status, and redraws
            } else {
                // If it's the first series, just clear its data points
                series[currentSeriesIndex] = [];
                // We need to manually update status and redraw since updateSeriesControls isn't called
                updateStatus();
                draw();
            }
            updateOutput(); // Update the text output area
        });

        newSeriesBtn.addEventListener('click', () => {
            saveState();
            currentSeriesIndex = series.length;
            series.push([]);
            updateSeriesControls();
        });

        seriesSelect.addEventListener('change', (e) => {
            saveState();
            currentSeriesIndex = parseInt(e.target.value, 10);
            // No need to call updateSeriesControls, just update status and redraw
            updateStatus();
            draw();
        });

        copyBtn.addEventListener('click', () => {
            const text = generateOutputText();
            navigator.clipboard.writeText(text).then(() => {
                const originalText = copyBtn.textContent;
                copyBtn.textContent = 'Copied!';
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                }, 2000);
            }).catch(err => {
                alert('Failed to copy to clipboard. Please select and copy manually.');
            });
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const { scaleX, scaleY } = getCanvasScale();
            const originalX = x / scaleX;
            const originalY = y / scaleY;

            // Check if clicking on an existing line handle
            const clickedLine = findLineAtPoint(originalX, originalY);

            if (clickedLine) {
                draggingLine = clickedLine;
                const currentPos = isVertical ? clickedLine.pos : clickedLine.pos; // This is in original coords
                e.preventDefault();
                return;
            }

            // If not dragging, place a new line (save state first)
            saveState();
            if (currentStep === 2 && scaleLines.length < 2) { // Place in original coords
                scaleLines.push({ pos: isVertical ? originalX : originalY, fixedCoord: isVertical ? originalY : originalX });
                if (scaleLines.length === 2) {
                    showScaleModal(2, e.clientX, e.clientY);
                    updateTabAccessibility();
                }
            } else if (currentStep === 3 && scale1Input.value && scale2Input.value) {
                series[currentSeriesIndex].push({ pos: isVertical ? originalX : originalY, fixedCoord: isVertical ? originalY : originalX });
                updateOutput();
            } else {
                history.pop(); // Don't save state if no action was taken
            }
            updateStatus();
            if (currentStep === 2 && scaleLines.length === 1) {
                showScaleModal(1, e.clientX, e.clientY);
            }
            draw();
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const { scaleX, scaleY } = getCanvasScale();
            const originalX = x / scaleX;
            const originalY = y / scaleY;

            if (draggingLine) {
                // Apply drag sensitivity
                const rawPos = (isVertical ? originalX : originalY) - dragOffset; // Convert mouse pos to original coords
                const currentPos = draggingLine.pos;
                const delta = (rawPos - currentPos) * DRAG_SENSITIVITY;
                draggingLine.pos = currentPos + delta;

                updateOutput();
                draw();
                e.preventDefault();
            } else {
                // Update cursor if hovering over a handle (use original coords)
                const hoveredLine = findLineAtPoint(originalX, originalY);
                // Update cursor if hovering over a handle (use original coords)
                canvas.style.cursor = hoveredLine ? 'grab' : 'crosshair';
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (draggingLine) {
                saveState(); // Save state after dragging completes
                canvas.style.cursor = 'crosshair';
            }
            draggingLine = null;
        });

        canvas.addEventListener('mouseleave', () => {
            draggingLine = null;
            canvas.style.cursor = 'crosshair';
        });

        function findLineAtPoint(x, y) {
            // Check scale lines first
            for (let line of scaleLines) {
                if (isNearHandle(x, y, line)) {
                    return line;
                }
            }
            // Then check data lines from all series
            for (let seriesLines of series) {
                for (let line of seriesLines) {
                    if (isNearHandle(x, y, line)) {
                        return line;
                    }
                }
            }
            return null;
        }

        function getCanvasScale() {
            if (!image || !canvas) return { scaleX: 1, scaleY: 1 };
            const displayWidth = canvas.offsetWidth;
            const displayHeight = canvas.offsetHeight;
            return {
                scaleX: displayWidth / image.width,
                scaleY: displayHeight / image.height
            };
        }

        function isNearHandle(x, y, line) {
            if (isVertical) {
                return Math.abs(x - line.pos) < DRAG_THRESHOLD &&
                       Math.abs(y - line.fixedCoord) < DRAG_THRESHOLD;
            } else {
                return Math.abs(y - line.pos) < DRAG_THRESHOLD &&
                       Math.abs(x - line.fixedCoord) < DRAG_THRESHOLD;
            }
        }

        scale1Input.addEventListener('input', updateOutput);
        scale2Input.addEventListener('input', updateOutput);

        function updateStatus() {
            let statusText = '';
            if (currentStep === 2) {
                if (scaleLines.length === 0) {
                    statusText = 'Click on the image to set the first scale reference line.';
                } else if (scaleLines.length === 1) {
                    statusText = 'Click to set the second scale reference line.';
                } else if (!scale1Input.value || !scale2Input.value) {
                    statusText = 'Enter the values for both reference lines above.';
                } else {
                    statusText = 'Scale set! You can now proceed to Step 3 to grab data points.';
                }
            } else if (currentStep === 3) {
                 const currentSeriesLines = series[currentSeriesIndex] || [];
                 statusText = `Click to add data points to Series ${currentSeriesIndex + 1}. (${currentSeriesLines.length} data point${currentSeriesLines.length !== 1 ? 's' : ''} in current series)`;
            }
            status.textContent = statusText;
            updateTabAccessibility();
        }

        // --- Scale Input Modal Logic ---
        const scaleModalContent = document.getElementById('scaleModalContent');
        const scaleModalHeader = document.getElementById('scaleModalHeader');
        const modalTitle = document.getElementById('modalTitle');
        const modalLabel = document.getElementById('modalLabel');
        const scaleValueInput = document.getElementById('scaleValueInput');
        const modalSubmitBtn = document.getElementById('modalSubmitBtn');
        let currentModalRef = 0;

        function showScaleModal(refNumber, x, y) {
            currentModalRef = refNumber;
            modalTitle.textContent = `Set Reference ${refNumber} Value`;
            modalLabel.htmlFor = `scaleValueInput`;
            modalLabel.textContent = `Reference Line ${refNumber} Value:`;
            scaleValueInput.value = refNumber === 1 ? scale1Input.value : scale2Input.value;
            
            // Position modal near the click event
            scaleModalContent.style.left = `${x + 20}px`;
            scaleModalContent.style.top = `${y - 40}px`;

            scaleModal.classList.remove('hidden');
            scaleValueInput.focus();
            scaleValueInput.select();
        }

        function hideScaleModal() {
            scaleModal.classList.add('hidden');
            updateOutput();
            updateTabAccessibility();
            draw();
        }

        modalSubmitBtn.addEventListener('click', () => {
            if (currentModalRef === 1) {
                scale1Input.value = scaleValueInput.value;
            } else {
                scale2Input.value = scaleValueInput.value;
            }
            hideScaleModal();
        });

        scaleValueInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                modalSubmitBtn.click();
            }
        });

        // Drag logic for the modal
        let isDraggingModal = false;
        let modalOffsetX, modalOffsetY;
        scaleModalHeader.addEventListener('mousedown', (e) => {
            isDraggingModal = true;
            modalOffsetX = e.clientX - scaleModalContent.offsetLeft;
            modalOffsetY = e.clientY - scaleModalContent.offsetTop;
        });
        document.addEventListener('mousemove', (e) => {
            if (!isDraggingModal) return;
            scaleModalContent.style.left = `${e.clientX - modalOffsetX}px`;
            scaleModalContent.style.top = `${e.clientY - modalOffsetY}px`;
        });
        document.addEventListener('mouseup', () => isDraggingModal = false);

        function draw() {
            const { scaleX, scaleY } = getCanvasScale();
            if (!image) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(image, 0, 0);

            // Draw scale lines (red)
            if (currentStep >= 2) { scaleLines.forEach((line, index) => {
                const displayPos = line.pos * (isVertical ? scaleX : scaleY);
                const displayFixedCoord = line.fixedCoord * (isVertical ? scaleY : scaleX);
                const isScaleStep = currentStep === 2;
                const isActive = draggingLine === line;
                
                let color = '#ff0000'; // Red for scale step
                if (!isScaleStep) color = '#888888'; // Grey for data step

                ctx.strokeStyle = isActive ? color : `${color}99`;
                ctx.lineWidth = 2;

                if (!isScaleStep) ctx.setLineDash([5, 5]); // Dashed in data step
                ctx.beginPath();
                if (isActive) {
                    // Draw full line when active
                    if (isVertical) {
                        ctx.moveTo(displayPos, 0);
                        ctx.lineTo(displayPos, canvas.height * scaleY); // Use scaled canvas height for end point
                    } else {
                        ctx.moveTo(0, displayPos);
                        ctx.lineTo(canvas.width * scaleX, displayPos); // Use scaled canvas width for end point
                    }
                } else {
                    // Draw short line around crosshair when inactive
                    if (isVertical) {
                        ctx.moveTo(displayPos, Math.max(0, displayFixedCoord - INACTIVE_LINE_LENGTH));
                        ctx.lineTo(displayPos, Math.min(canvas.height * scaleY, displayFixedCoord + INACTIVE_LINE_LENGTH));
                    } else {
                        ctx.moveTo(Math.max(0, displayFixedCoord - INACTIVE_LINE_LENGTH), displayPos);
                        ctx.lineTo(Math.min(canvas.width * scaleX, displayFixedCoord + INACTIVE_LINE_LENGTH), displayPos);
                    }
                }
                ctx.stroke();
                ctx.setLineDash([]); // Reset dash for other lines

                // Draw crosshair handle at the fixed coordinate
                drawHandle(displayPos, displayFixedCoord, isActive ? color : `${color}99`);

                // Label
                ctx.fillStyle = isActive ? color : `${color}99`;
                ctx.font = `${12 / Math.min(scaleX, scaleY)}px Arial`; // Scale font size inversely to canvas scale
                const label = `Ref ${index + 1}`;
                if (isVertical) {
                    ctx.fillText(label, displayPos + 5, 15);
                } else {
                    ctx.fillText(label, 5, displayPos - 5);
                }
            });}

            // Draw data lines from all series
            if (currentStep === 3) {
                series.forEach((seriesLines, seriesIndex) => {
                const color = SERIES_COLORS[seriesIndex % SERIES_COLORS.length];
                const isCurrentSeries = seriesIndex === currentSeriesIndex;

                seriesLines.forEach((line, lineIndex) => {
                    const displayPos = line.pos * (isVertical ? scaleX : scaleY);
                    const displayFixedCoord = line.fixedCoord * (isVertical ? scaleY : scaleX);
                    const isActive = draggingLine === line;
                    ctx.strokeStyle = isActive ? color.active : color.inactive;
                    ctx.lineWidth = 1.5;

                    ctx.beginPath();
                    if (isActive) {
                        // Draw full line when active
                        if (isVertical) {
                            ctx.moveTo(displayPos, 0);
                            ctx.lineTo(displayPos, canvas.height * scaleY);
                        } else {
                            ctx.moveTo(0, displayPos);
                            ctx.lineTo(canvas.width * scaleX, displayPos);
                        }
                    } else {
                        // Draw short line around crosshair when inactive
                        if (isVertical) {
                            ctx.moveTo(displayPos, Math.max(0, displayFixedCoord - INACTIVE_LINE_LENGTH));
                            ctx.lineTo(displayPos, Math.min(canvas.height * scaleY, displayFixedCoord + INACTIVE_LINE_LENGTH));
                        } else {
                            ctx.moveTo(Math.max(0, displayFixedCoord - INACTIVE_LINE_LENGTH), displayPos);
                            ctx.lineTo(Math.min(canvas.width * scaleX, displayFixedCoord + INACTIVE_LINE_LENGTH), displayPos);
                        }
                    }
                    ctx.stroke();

                    // Draw crosshair handle at the fixed coordinate
                    drawHandle(displayPos, displayFixedCoord, isActive ? color.active : color.inactive);

                    // Label with series indicator
                    ctx.fillStyle = isActive ? color.active : color.inactive;
                    ctx.font = `${11 / Math.min(scaleX, scaleY)}px Arial`;
                    const label = `S${seriesIndex + 1}:${lineIndex + 1}`;
                    if (isVertical) {
                        ctx.fillText(label, displayPos + 3, 30 + (seriesIndex * 15));
                    } else {
                        ctx.fillText(label, 5 + (seriesIndex * 35), displayPos - 5);
                    }
                });
            });}
        }

        function drawHandle(linePos, fixedCoord, color) {
            const handleSize = 8;
            ctx.strokeStyle = color;
            ctx.lineWidth = 1; // Handle line width can remain constant or scale

            if (isVertical) {
                // Draw small crosshair at (linePos, fixedCoord)
                ctx.beginPath();
                ctx.moveTo(linePos - handleSize, fixedCoord);
                ctx.lineTo(linePos + handleSize, fixedCoord);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(linePos, fixedCoord - handleSize);
                ctx.lineTo(linePos, fixedCoord + handleSize);
                ctx.stroke();
            } else {
                // Draw small crosshair at (fixedCoord, linePos)
                ctx.beginPath();
                ctx.moveTo(fixedCoord - handleSize, linePos);
                ctx.lineTo(fixedCoord + handleSize, linePos);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(fixedCoord, linePos - handleSize);
                ctx.lineTo(fixedCoord, linePos + handleSize);
                ctx.stroke();
            }
        }

        function calculateValue(position) {
            if (scaleLines.length < 2 || !scale1Input.value || !scale2Input.value) {
                return null;
            }

            const pos1 = scaleLines[0].pos;
            const pos2 = scaleLines[1].pos;
            const val1 = parseFloat(scale1Input.value);
            const val2 = parseFloat(scale2Input.value);

            // Linear interpolation
            const ratio = (position - pos1) / (pos2 - pos1);
            const value = val1 + ratio * (val2 - val1);

            return value.toFixed(2);
        }

        function generateOutputText() {
            if (!scale1Input.value || !scale2Input.value) {
                return 'No data points yet. Click on the chart to add data points.';
            }

            // Check if any series has data
            const hasData = series.some(s => s.length > 0);
            if (!hasData) {
                return 'No data points yet. Click on the chart to add data points.';
            }

            // Find max number of rows needed
            const maxRows = Math.max(...series.map(s => s.length));

            // Build header
            let result = 'Index';
            for (let i = 0; i < series.length; i++) {
                if (series[i].length > 0) {
                    result += `\tSeries ${i + 1}`;
                }
            }
            result += '\n';

            // Build data rows
            for (let row = 0; row < maxRows; row++) {
                result += (row + 1);
                for (let seriesIndex = 0; seriesIndex < series.length; seriesIndex++) {
                    if (series[seriesIndex].length > 0) {
                        const line = series[seriesIndex][row];
                        if (line) {
                            const value = calculateValue(line.pos);
                            result += `\t${value}`;
                        } else {
                            result += '\t';
                        }
                    }
                }
                result += '\n';
            }

            return result;
        }

        function updateOutput() {
            output.textContent = generateOutputText();
            updateTabAccessibility();
        }

        // updateTabAccessibility(); // Initial call is now handled by goToStep(1)
    </script>
</body>



</html>